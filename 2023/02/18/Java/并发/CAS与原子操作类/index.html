<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="CAS原子类何为原子类 即为java.util.concurrent.atomic包下的所有相关类和API  没有CAS之前 多线程环境不使用原子类保证线程安全i++（基本数据类型）  常用synchronized锁，但是它比较重 ，牵扯到了用户态和内核态的切换,效率不高。 1234567891011121314public class T3&amp;#123;    volatile int numbe">
<meta property="og:type" content="article">
<meta property="og:title" content="CAS与原子操作类">
<meta property="og:url" content="https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/index.html">
<meta property="og:site_name" content="Yumo&#39;s Blog">
<meta property="og:description" content="CAS原子类何为原子类 即为java.util.concurrent.atomic包下的所有相关类和API  没有CAS之前 多线程环境不使用原子类保证线程安全i++（基本数据类型）  常用synchronized锁，但是它比较重 ，牵扯到了用户态和内核态的切换,效率不高。 1234567891011121314public class T3&amp;#123;    volatile int numbe">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/ac73fe695b2a4459b2d6a4f1a806bb9e.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217135239396.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217135926241.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217141429005.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217141853201.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/7f21bd661213470da7155a7863b497fa.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217144924368.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217144935972.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217145009420.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217144935972.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217151344678.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217144935972.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217194600916.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/3f9e938eb8994f538464e7fd811429e2.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217195106962.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/d1b38b7879d14f848d918ff09c4af6fc.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217201632479.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/4e95b66e40ce42bd963095c87767d350.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217212637552.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217212615739.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218113219560.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218113350198.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218113634993.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218113744851.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218114633330.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218114825119.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218114837978.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/6c09ac463901435ca58d43fd2b0c08a8.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218124943225.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218125225202.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218132219191.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218132243773.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218132532652.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218132841655.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218133646309.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218135606027.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218135849240.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140007490.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140123894.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140245454.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140354879.png">
<meta property="og:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140759151.png">
<meta property="article:published_time" content="2023-02-18T08:51:33.000Z">
<meta property="article:modified_time" content="2023-09-28T08:05:35.187Z">
<meta property="article:author" content="Yumo">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/ac73fe695b2a4459b2d6a4f1a806bb9e.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/android-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>CAS与原子操作类</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Yumo's Blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Archives</a></li><!--
     --><!--
       --><li><a href="/tags/">Tags</a></li><!--
     --><!--
       --><li><a href="/categories/">Categorys</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/atom.xml">RSS</a></li><!--
     --><!--
       --><li><a href="/infinite/">Infinite</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/02/19/Java/%E5%B9%B6%E5%8F%91/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%8F%8ASynchronized%E9%94%81%E5%8D%87%E7%BA%A7/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CompletableFuture/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&text=CAS与原子操作类"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&is_video=false&description=CAS与原子操作类"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CAS与原子操作类&body=Check out this article: https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&name=CAS与原子操作类&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&t=CAS与原子操作类"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS"><span class="toc-number">1.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89CAS%E4%B9%8B%E5%89%8D"><span class="toc-number">1.2.</span> <span class="toc-text">没有CAS之前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CAS%E4%B9%8B%E5%90%8E"><span class="toc-number">1.3.</span> <span class="toc-text">使用CAS之后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.</span> <span class="toc-text">CAS是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">CAS基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">CAS原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CASDemo%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.3.</span> <span class="toc-text">CASDemo代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BA%A7%E5%88%AB%E4%BF%9D%E8%AF%81"><span class="toc-number">1.4.4.</span> <span class="toc-text">硬件级别保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.5.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F%E5%A6%82%E6%9E%9C%E7%9F%A5%E9%81%93%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9UnSafe%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">CAS底层原理？如果知道，谈谈你对UnSafe的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UnSafe"><span class="toc-number">1.5.1.</span> <span class="toc-text">UnSafe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93i-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E9%82%A3atomicInteger-getAndIncrement"><span class="toc-number">1.5.2.</span> <span class="toc-text">我们知道i++线程不安全的，那atomicInteger.getAndIncrement()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%B1%87%E7%BC%96"><span class="toc-number">1.5.4.</span> <span class="toc-text">底层汇编</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">自定义原子引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E4%B8%8E%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E5%80%9F%E9%89%B4CAS%E6%80%9D%E6%83%B3"><span class="toc-number">1.7.</span> <span class="toc-text">CAS与自旋锁，借鉴CAS思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81SpinLockDemo"><span class="toc-number">1.7.2.</span> <span class="toc-text">自己实现一个自旋锁SpinLockDemo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E7%BC%BA%E7%82%B9"><span class="toc-number">1.8.</span> <span class="toc-text">CAS缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%BE%88%E5%A4%A7"><span class="toc-number">1.8.1.</span> <span class="toc-text">1 循环时间长开销很大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E5%87%BA%E6%9D%A5ABA%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.2.</span> <span class="toc-text">2 引出来ABA问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">原子操作类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">再分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">基本类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-number">2.3.1.</span> <span class="toc-text">常用API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-CountDownLatch"><span class="toc-number">2.3.2.</span> <span class="toc-text">Case-CountDownLatch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">数组类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Case"><span class="toc-number">2.4.1.</span> <span class="toc-text">Case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">引用类型原子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text">对象的属性修改原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84"><span class="toc-number">2.6.1.</span> <span class="toc-text">使用目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A6%81%E6%B1%82"><span class="toc-number">2.6.2.</span> <span class="toc-text">使用要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-1"><span class="toc-number">2.6.3.</span> <span class="toc-text">Case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">2.6.4.</span> <span class="toc-text">面试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%BC%BA%E7%B1%BB%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">2.7.</span> <span class="toc-text">原子操作增强类原理深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E8%A6%81%E5%91%BD%E9%A2%98%E7%9B%AE"><span class="toc-number">2.7.1.</span> <span class="toc-text">阿里要命题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%B8%8B%E7%82%B9%E8%B5%9E%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%8C%E7%9C%8B%E7%9C%8B%E6%80%A7%E8%83%BD"><span class="toc-number">2.7.2.</span> <span class="toc-text">模拟下点赞计数器，看看性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API-1"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">常用API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">入门讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LongAdder%E9%AB%98%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94Code%E6%BC%94%E7%A4%BA"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">LongAdder高性能对比Code演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">2.7.3.</span> <span class="toc-text">源码、原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%88LongAdder%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%89"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">原理（LongAdder为什么这么快）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Striped64"><span class="toc-number">2.7.3.2.1.</span> <span class="toc-text">Striped64</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Cell"><span class="toc-number">2.7.3.2.2.</span> <span class="toc-text">Cell</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">源码解读深度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LongAdder-increment"><span class="toc-number">2.7.3.3.1.</span> <span class="toc-text">LongAdder.increment()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#add-1L"><span class="toc-number">2.7.3.3.1.1.</span> <span class="toc-text">add(1L)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#longAccumulate"><span class="toc-number">2.7.3.3.1.2.</span> <span class="toc-text">longAccumulate()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sum"><span class="toc-number">2.7.3.3.1.3.</span> <span class="toc-text">sum()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.3.4.</span> <span class="toc-text">使用总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.4.</span> <span class="toc-text">小总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicLong"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">AtomicLong</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.4.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.4.1.2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">2.7.4.1.3.</span> <span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LongAdder"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">LongAdder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.7.4.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.7.4.2.2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7-1"><span class="toc-number">2.7.4.2.3.</span> <span class="toc-text">缺陷</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text"></span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        CAS与原子操作类
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Yumo</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-02-18T08:51:33.000Z" class="dt-published" itemprop="datePublished">2023-02-18</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/JUC/" rel="tag">JUC</a>, <a class="p-category" href="/tags/Java/" rel="tag">Java</a>, <a class="p-category" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>何为原子类</p>
<p>即为java.util.concurrent.atomic包下的所有相关类和API</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/ac73fe695b2a4459b2d6a4f1a806bb9e.png" alt="在这里插入图片描述"></p>
<h2 id="没有CAS之前"><a href="#没有CAS之前" class="headerlink" title="没有CAS之前"></a>没有CAS之前</h2><ul>
<li>多线程环境<strong>不使用</strong>原子类保证线程安全i++（基本数据类型）</li>
</ul>
<p>常用<code>synchronized</code>锁，但是它比较重 ，牵扯到了用户态和内核态的切换,效率不高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入加锁保证原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用CAS之后"><a href="#使用CAS之后" class="headerlink" title="使用CAS之后"></a>使用CAS之后</h2><ul>
<li>多线程情况下<strong>使用原子类</strong>保证线程安全（基本数据类型）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入加锁保证原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//=================================</span></span><br><span class="line">    <span class="comment">//下面是新版本</span></span><br><span class="line">    <span class="comment">//=================================</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtomicInteger</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtomicInteger</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        atomicInteger.getAndIncrement();<span class="comment">//先读再加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类似于乐观锁</li>
</ul>
<h2 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h2><h3 id="CAS基本知识"><a href="#CAS基本知识" class="headerlink" title="CAS基本知识"></a>CAS基本知识</h3><p>compare and swap的缩写，中文翻译成<strong>比较并交换</strong>,实现并发算法时常用到的一种技术。它包含三个操作数——<strong>内存位置</strong>、<strong>预期原值</strong>及<strong>更新值</strong>。</p>
<p>执行CAS操作的时候，将内存位置的值与预期原值比较：</p>
<ul>
<li>如果<strong>相匹配</strong>，那么处理器会自动将该位置值更新为新值，</li>
<li>如果<strong>不匹配</strong>，处理器不做任何操作，多个线程同时执行CAS操作<strong>只有一个会成功</strong>。</li>
</ul>
<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>CAS （CompareAndSwap）</p>
<p>CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。<br>当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来*</p>
<p>当它重来重试的这种行为成为—<strong>自旋</strong></p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217135239396.png" alt="image-20230217135239396"></p>
<ul>
<li>eg</li>
<li>线程A读取了值为5，想要更新为6，想要将值写回的时候发现线程B和C都进行了操作，已经变成了7，这个时候A不能成功，可能会发生自旋</li>
</ul>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217135926241.png" alt="image-20230217135926241"></p>
<h3 id="CASDemo代码"><a href="#CASDemo代码" class="headerlink" title="CASDemo代码"></a>CASDemo代码</h3><p>多线程情况下<strong>使用原子类</strong>保证线程安全（基本数据类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2022</span>)+<span class="string">&quot;\t&quot;</span>+atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>)+<span class="string">&quot;\t&quot;</span>+atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true 2022</span></span><br><span class="line"><span class="comment">//false 2022</span></span><br></pre></td></tr></table></figure>

<h3 id="硬件级别保证"><a href="#硬件级别保证" class="headerlink" title="硬件级别保证"></a>硬件级别保证</h3><p>对总线加锁，效率比synchronized效率高。</p>
<ul>
<li><p>CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。</p>
</li>
<li><p>它是非阻塞的且自身原子性，也就是说这玩意效率更高且通过硬件保证，说明这玩意更可靠。</p>
</li>
<li><p>CAS是一条CPU的<em>原子指令</em> （<code>cmpxchg指令</code>），不会造成所谓的数据不一致问题，<code>Unsafe</code>提供的<code>CAS方法</code>（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。</p>
</li>
<li><p>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就<strong>给总线加锁，</strong>只有一个<strong>线程会对总线加锁</strong>成功 </p>
<p>加锁成功之后会执行cas操作，也就是说<strong>CAS的原子性实际上是CPU实现独占的</strong> ， 其实在这一点上还是有排他锁的</p>
<p>只是比起用synchronized， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好</p>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>jdk8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//compareAndSet</span><br><span class="line">//发现它调用了Unsafe类</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//compareAndSwapInt</span><br><span class="line">//发现它调用了native方法</span><br><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                                 Object expected,</span></span><br><span class="line"><span class="params">                                                 Object x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> expected,</span></span><br><span class="line"><span class="params">                                              <span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                               <span class="type">long</span> expected,</span></span><br><span class="line"><span class="params">                                               <span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>上面三个方法都是类似的，主要对4个参数做一下说明。</p>
<ul>
<li>o：表示要操作的对象</li>
<li>offset：表示要操作对象中属性地址的偏移量</li>
<li>expected：表示需要修改数据的期望的值</li>
<li>x：表示需要修改为的新值</li>
</ul>
<p>jdk17</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetInt(<span class="built_in">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217141429005.png" alt="image-20230217141429005"></p>
<blockquote>
<p>引出来一个问题：Unsafe类是什么？</p>
</blockquote>
<h2 id="CAS底层原理？如果知道，谈谈你对UnSafe的理解"><a href="#CAS底层原理？如果知道，谈谈你对UnSafe的理解" class="headerlink" title="CAS底层原理？如果知道，谈谈你对UnSafe的理解"></a>CAS底层原理？如果知道，谈谈你对UnSafe的理解</h2><h3 id="UnSafe"><a href="#UnSafe" class="headerlink" title="UnSafe"></a>UnSafe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;<span class="comment">//保证变量修改后多线程之间的可见性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Unsafe</p>
<p>CAS这个理念 ，落地就是Unsafe类</p>
<p>它是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门 ，基于该类可以直接操作特定内存\ 的数据 。<strong>Unsafe类存在于sun.misc包中</strong>，其内部方法操作可以像C的<strong>指针</strong>一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p>
<p>注意Unsafe类中的所有方法都是native修饰的，也就是说<strong>Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</strong> 。</p>
<p>打开rt.jar包（最基本的包）<br><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217141853201.png" alt="image-20230217141853201"></p>
</li>
<li><p>变量<code>valueOffset</code>，表示该变量值在内存中的<strong>偏移地址</strong>，因为Unsafe就是根据内存偏移地址获取数据的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量value用<strong>volatile</strong>修饰，保证了多线程之间的内存可见性。</p>
</li>
</ul>
<h3 id="我们知道i-线程不安全的，那atomicInteger-getAndIncrement"><a href="#我们知道i-线程不安全的，那atomicInteger-getAndIncrement" class="headerlink" title="我们知道i++线程不安全的，那atomicInteger.getAndIncrement()"></a>我们知道i++线程不安全的，那atomicInteger.getAndIncrement()</h3><p>CAS的全称为Compare-And-Swap，<strong>它是一条CPU并发原语</strong>。</p>
<p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p>
<p>AtomicInteger 类主要利用 <code>CAS (compare and swap)</code> + <code>volatile</code> 和 <code>native</code> 方法来保证原子操作，从而避免 <code>synchronized</code> 的高开销，执行效率大为提升。</p>
<ul>
<li>jdk8</li>
</ul>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/7f21bd661213470da7155a7863b497fa.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>jdk17</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217144924368.png" alt="image-20230217144924368"></p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217144935972.png" alt="image-20230217144935972"></p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217145009420.png" alt="image-20230217145009420"></p>
</li>
</ul>
<p>CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出<strong>CAS汇编指令</strong> 。这是一种完全依赖于<strong>硬件</strong>的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语 ，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，<strong>并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题</strong>。</p>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>若在OpenJDK源码中查看Unsafe.java</p>
<ul>
<li><p>这里while体现了<strong>自旋</strong>的思想</p>
</li>
<li><p>假如是ture,取反false退出循环；假如是false，取反true要继续循环。</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217144935972.png" alt="image-20230217144935972"></p>
</li>
<li><p>原理</p>
<ul>
<li>假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同CPU上）：</li>
<li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存。</li>
<li>线程A通过getIntVolatile(var1, var2)拿到value值3，这时线程A被<strong>挂起</strong> 。</li>
<li>线程B也通过getIntVolatile(var1, var2)方法获取到value值3，此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切OK。</li>
<li>这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值数字3和主内存的值数字4不一致，说明该值已经被其它线程抢先一步修改过了，那A线程本次修改失败，<strong>只能重新读取重新来一遍了</strong>。</li>
<li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li>
</ul>
</li>
</ul>
<h3 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h3><p>了解即可</p>
<ul>
<li><p><code>Unsafe</code>类中的<code>compareAndSwapInt</code>，是一个本地方法，该方法的实现位于<code>unsafe.cpp</code>中*</p>
</li>
<li><p>核心<code>(Atomic::cmpxchg(x, addr, e)) == e;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv* env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">     UnsafeWrapper(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">     oop p = JNIHandles::resolve(obj);</span><br><span class="line">   <span class="comment">// 先想办法拿到变量value在内存中的地址，根据偏移量valueOffset，计算 value 的地址</span></span><br><span class="line">     jint* addr = (jint* ) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">   <span class="comment">// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是要交换的值，e是要比较的值</span></span><br><span class="line">   <span class="comment">//cas成功，返回期望值e，等于e，此方法返回true;</span></span><br><span class="line">   <span class="comment">//cas失败，返回内存中的value值，不等于e，此方法返回false</span></span><br><span class="line">     <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">   UNSAFE_END</span><br><span class="line">   <span class="comment">//-------------核心(Atomic::cmpxchg(x, addr, e)) == e;</span></span><br><span class="line">   <span class="comment">//JDK提供的CAS机制，在汇编层级会禁止变量两侧的指令优化，然后使用cmpxchg指令比较并更新变量值（原子性）</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>再看看<code>cmpxchg</code>里面是什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">Atomic::cmpxchg</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> exchange_value,<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>* dest, <span class="type">unsigned</span> <span class="type">int</span> compare_value)</span> &#123;</span><br><span class="line">    assert(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="keyword">sizeof</span>(jint), <span class="string">&quot;more work to do&quot;</span>);</span><br><span class="line">    <span class="comment">//根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载函数</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)Atomic::cmpxchg((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest, (jint)compare_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>不同的操作系统下会调用不同的compxchg重载函数，例如win10</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint <span class="title function_">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> &#123;</span><br><span class="line">  <span class="comment">//判断是否是多核CPU</span></span><br><span class="line">  <span class="type">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    <span class="comment">//三个move指令表示的是将后面的值移动到前面的寄存器上</span></span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    <span class="comment">//CPU原语级别，CPU触发</span></span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    <span class="comment">//比较并交换指令</span></span><br><span class="line">    <span class="comment">//cmpxchg: 即“比较并交换”指令</span></span><br><span class="line">    <span class="comment">//dword: 全称是 double word 表示两个字，一共四个字节</span></span><br><span class="line">    <span class="comment">//ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 </span></span><br><span class="line">    <span class="comment">//将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值进行对比，</span></span><br><span class="line">    <span class="comment">//如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结</p>
<p>你只需要记住：CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性</p>
<p>实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令<strong>cmpxchg</strong>指令。</p>
<p>核心思想就是：比较<strong>要更新变量的值V（内存offset上的值）</strong>和<strong>预期值E（volatile取得的值）</strong>（compare），相等才会将V的值设为<strong>新值N</strong>（swap&#x2F;set）。如果不相等自旋再来。</p>
</li>
</ul>
<h2 id="自定义原子引用"><a href="#自定义原子引用" class="headerlink" title="自定义原子引用"></a>自定义原子引用</h2><ul>
<li><p>譬如AtomicInteger原子整型，可有其他原子类型，比如AtomicBook、AtomicOrder</p>
</li>
<li><p>丢入泛型中<code>Class AtomicReference&lt;V&gt;</code></p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217151344678.png" alt="image-20230217151344678"></p>
</li>
<li><p>eg</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">z3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;z3&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">li4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;li4&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, li4)+<span class="string">&quot;\t&quot;</span>+atomicReference.get().toString());</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, li4)+<span class="string">&quot;\t&quot;</span>+atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true	User(userName=li4, age=26)</span></span><br><span class="line"><span class="comment">//false	User(userName=li4, age=26</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CAS与自旋锁，借鉴CAS思想"><a href="#CAS与自旋锁，借鉴CAS思想" class="headerlink" title="CAS与自旋锁，借鉴CAS思想"></a>CAS与自旋锁，借鉴CAS思想</h2><p>CAS落地的重要应用-自旋锁</p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><strong>自旋锁（spinlock）</strong></p>
<p>是指尝试获取锁的线程不会立即阻塞，而是采用<strong>循环的方式</strong>去尝试<strong>获取锁</strong> ，</p>
<p>当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会<strong>消耗CPU</strong>。</p>
<p>若在OpenJDK源码中查看Unsafe.java</p>
<ul>
<li><p>这里while体现了<strong>自旋</strong>的思想</p>
</li>
<li><p>假如是ture,取反false退出循环；假如是false，取反true要继续循环，尝试CAS操作，直到返回true。</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217144935972.png" alt="image-20230217144935972"></p>
</li>
</ul>
<h3 id="自己实现一个自旋锁SpinLockDemo"><a href="#自己实现一个自旋锁SpinLockDemo" class="headerlink" title="自己实现一个自旋锁SpinLockDemo"></a>自己实现一个自旋锁SpinLockDemo</h3><ul>
<li><p>题目：实现一个自旋锁<br>自旋锁好处：循环比较获取没有类似wait的阻塞。</p>
<p>通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现<br>当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: yumo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 实现一个自旋锁</span></span><br><span class="line"><span class="comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁2秒钟，B随后进来后发现</span></span><br><span class="line"><span class="comment"> * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/17 15:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span> &#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\tcome in,lock&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(thread, <span class="literal">null</span>)) &#123;&#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\tend,unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123; TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>); &#125;<span class="keyword">catch</span>(InterruptedException e)&#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.lock();</span><br><span class="line"></span><br><span class="line">            spinLockDemo.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><h3 id="1-循环时间长开销很大"><a href="#1-循环时间长开销很大" class="headerlink" title="1 循环时间长开销很大"></a>1 循环时间长开销很大</h3><p><code>do while </code>如果它一直自旋会一直占用CPU时间，造成较大的开销</p>
<p>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p>
<h3 id="2-引出来ABA问题"><a href="#2-引出来ABA问题" class="headerlink" title="2 引出来ABA问题"></a>2 引出来ABA问题</h3><ul>
<li><p>什么是ABA问题</p>
<p>CAS会导致“ABA问题”。</p>
<p>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个<strong>时间差</strong>类会导致数据的变化。</p>
<p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，</p>
<p>然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。</p>
<p>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p>
</li>
<li><p>如何解决</p>
<p><strong>AtomicStampedReference</strong>版本号 （注意区分前面的**Class AtomicReference<V>**）</p>
<p><strong>Class AtomicStampedReference<V></strong> 相关API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicStampedReference(V initialRef, <span class="type">int</span> initialStamp)</span><br><span class="line">创建一个新的 AtomicStampedReference与给定的初始值。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">weakCompareAndSet</span><span class="params">(V expectedReference,//旧值</span></span><br><span class="line"><span class="params">                                 V newReference,//新值</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> expectedStamp,//旧版本号</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> newStamp)</span><span class="comment">//新版本号</span></span><br><span class="line">    以原子方式设置该引用和邮票给定的更新值的值，如果当前的参考是==至预期的参考，并且当前标志等于预期标志。</span><br><span class="line">    May fail spuriously and does not provide ordering guarantees ，所以只是很少适合替代compareAndSet 。</span><br><span class="line"></span><br><span class="line">    参数</span><br><span class="line">    expectedReference - 参考的预期值</span><br><span class="line">    newReference - 参考的新值</span><br><span class="line">    expectedStamp - 邮票的预期值</span><br><span class="line">    newStamp - 邮票的新值</span><br><span class="line">    结果</span><br><span class="line">    <span class="literal">true</span>如果成功</span><br><span class="line">    ```*</span><br></pre></td></tr></table></figure>
</li>
<li><p>eg</p>
<ul>
<li>基本情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStampedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">javaBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1</span>, <span class="string">&quot;javaBook&quot;</span>);</span><br><span class="line">        AtomicStampedReference&lt;Book&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(javaBook,<span class="number">1</span>);</span><br><span class="line">        System.out.println(stampedReference.getReference()+<span class="string">&quot;\t&quot;</span>+stampedReference.getReference());</span><br><span class="line">        <span class="type">Book</span> <span class="variable">mysqlBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2</span>, <span class="string">&quot;mysqlBook&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        b= stampedReference.compareAndSet(javaBook, mysqlBook, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">        System.out.println(b+<span class="string">&quot;\t&quot;</span>+stampedReference.getReference()+<span class="string">&quot;\t&quot;</span>+stampedReference.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Book(id=1, bookName=javaBook)  Book(id=1, bookName=javaBook)</span></span><br><span class="line"><span class="comment">//true  Book(id=2, bookName=mysqlBook)  2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ABA复现（单线程情况下）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStampedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">javaBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1</span>, <span class="string">&quot;javaBook&quot;</span>);</span><br><span class="line">        AtomicStampedReference&lt;Book&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(javaBook,<span class="number">1</span>);</span><br><span class="line">        System.out.println(stampedReference.getReference()+<span class="string">&quot;\t&quot;</span>+stampedReference.getReference());</span><br><span class="line">        <span class="type">Book</span> <span class="variable">mysqlBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2</span>, <span class="string">&quot;mysqlBook&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        b= stampedReference.compareAndSet(javaBook, mysqlBook, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">        System.out.println(b+<span class="string">&quot;\t&quot;</span>+stampedReference.getReference()+<span class="string">&quot;\t&quot;</span>+stampedReference.getStamp());</span><br><span class="line">        b= stampedReference.compareAndSet(mysqlBook,javaBook, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">        System.out.println(b+<span class="string">&quot;\t&quot;</span>+stampedReference.getReference()+<span class="string">&quot;\t&quot;</span>+stampedReference.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Book(id=1, bookName=javaBook)  Book(id=1, bookName=javaBook) --------</span></span><br><span class="line"><span class="comment">//true  Book(id=2, bookName=mysqlBook)  2</span></span><br><span class="line"><span class="comment">//true  Book(id=1, bookName=javaBook)  3  --------虽然1.3行内容是一样的，但是版本号不一样</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>ABA复现（多线程情况下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicStampedReference</span> <span class="variable">atomicStampedReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);<span class="comment">//这里 中间就有人动过了，虽然值是不变的，假如不检查版本号，CAS就直接能成功了</span></span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep( <span class="number">500</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;;            </span><br><span class="line">            System.out.println(atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">2022</span>)+<span class="string">&quot;\t&quot;</span>+atomicInteger.get());</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-------------------- true-2022</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停一会儿线程,main彻底等待上面的ABA出现演示完成。</span></span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep( <span class="number">2000</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决=============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 首次版本号:&quot;</span>+stamp);<span class="comment">//1-----------初始获得一样的版本号</span></span><br><span class="line">            <span class="comment">//暂停500毫秒，保证t4线程初始化拿到的版本号和我一样,</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep( <span class="number">500</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 2次版本号:&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 3次版本号:&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();<span class="comment">//记录一开始的版本号，并且写死</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 首次版本号:&quot;</span>+stamp);<span class="comment">//1------------初始获得一样的版本号</span></span><br><span class="line">            <span class="comment">//暂停1秒钟线程，等待上面的t3线程，发生了ABA问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">2019</span>,stamp,stamp+<span class="number">1</span>);<span class="comment">//这个还是初始的版本号，但是实际上版本号被T3修改了，所以肯定会失败</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+result+<span class="string">&quot;\t&quot;</span>+atomicStampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//t3 首次版本号：1</span></span><br><span class="line"><span class="comment">//t4 首次版本号：1</span></span><br><span class="line"><span class="comment">//t3 2次版本号：2</span></span><br><span class="line"><span class="comment">//t3 3次版本号：3</span></span><br><span class="line"><span class="comment">//false 100 3   -----因为版本号实际上已经被修改了</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>总结：<strong>版本号</strong>+<strong>比较</strong>要一起上</p>
</li>
</ul>
<hr>
<h1 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h1><h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>都是<code>java.util.concurrent.atomic</code>包下的</p>
<p>有红框圈起来的，也有蓝框圈起来的，为什么？</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217194600916.png" alt="image-20230217194600916"></p>
<ul>
<li><p>阿里巴巴Java开发手册</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/3f9e938eb8994f538464e7fd811429e2.png" alt="在这里插入图片描述"></p>
</li>
<li><p>为什么说18罗汉增强，却只有16个</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217195106962.png" alt="image-20230217195106962"></p>
</li>
</ul>
<h2 id="再分类"><a href="#再分类" class="headerlink" title="再分类"></a>再分类</h2><h2 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h2><ul>
<li>AtomicInteger</li>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
</ul>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> new Value)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">comapreAndSet</span><span class="params">(<span class="type">int</span> expect,<span class="type">int</span> update)</span><span class="comment">//如果</span></span><br></pre></td></tr></table></figure>

<h3 id="Case-CountDownLatch"><a href="#Case-CountDownLatch" class="headerlink" title="Case-CountDownLatch"></a>Case-CountDownLatch</h3><ul>
<li><p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span>&#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= SIZE;i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">1000</span>;j ++)&#123;</span><br><span class="line">                    myNumber.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;result: &quot;</span>+myNumber.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本来应该是50000</span></span><br><span class="line"><span class="comment">//1试-main  result: 39000</span></span><br><span class="line"><span class="comment">//2试-main  result: 40178</span></span><br><span class="line"><span class="comment">//?是不是我们的程序有问题？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为上面的50*  1000个计算还没结束，他就去get数值了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一（不推荐，做做Demo还行）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= SIZE;i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">1000</span>;j ++)&#123;</span><br><span class="line">                    myNumber.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;result: &quot;</span>+myNumber.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二-减法计数器CountDownLatch</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= SIZE;i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">1000</span>;j ++)&#123;</span><br><span class="line">                        myNumber.addPlusPlus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;result: &quot;</span>+myNumber.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main  result: 50000</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h2><p>基本原理同上，不做过多演示</p>
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicRreferenceArray</li>
</ul>
<h3 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AtomicIntegerArray</span> <span class="variable">atomicIntegerArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]);<span class="comment">//0 0 0 0 0</span></span><br><span class="line">        <span class="comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(5);</span></span><br><span class="line">        <span class="comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[]&#123;1,2,3,4,5&#125;);//1 2 3 4 5 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;atomicIntegerArray.length(); i++) &#123;</span><br><span class="line">            System.out.println(atomicIntegerArray.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpInt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        tmpInt = atomicIntegerArray.getAndSet(<span class="number">0</span>,<span class="number">1122</span>);</span><br><span class="line">        System.out.println(tmpInt+<span class="string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="number">0</span>));</span><br><span class="line">        atomicIntegerArray.getAndIncrement(<span class="number">1</span>);</span><br><span class="line">        atomicIntegerArray.getAndIncrement(<span class="number">1</span>);</span><br><span class="line">        tmpInt = atomicIntegerArray.getAndIncrement(<span class="number">1</span>);</span><br><span class="line">        System.out.println(tmpInt+<span class="string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h2><p>这三个相对比较重要</p>
<ul>
<li><p>AtomicReference</p>
</li>
<li><p>AtomicStampedReference</p>
</li>
<li><p>AtomicMarkableReference</p>
</li>
<li><p><code>AtomicReference</code> 可以带泛型（前面讲过）</p>
<ul>
<li><code>AtomicReference&lt;xxx&gt;</code></li>
</ul>
</li>
<li><p><code>AtomicStampedReference</code> 带版本号以防CAS中的ABA问题（前面讲过）</p>
<ul>
<li>携带版本号的引用类型原子类，可以解决ABA问题。解决修改过几次的问题。*</li>
</ul>
</li>
<li><p><code>AtomicMarkableReference</code>类似于上面的 ，但解决<strong>一次性</strong>问题</p>
<ul>
<li>构造法<code>AtomicMarkableReference(V initialRef, boolean initialMark)</code></li>
<li>原子更新带有标记位的引用类型对象</li>
<li>解决是否修改过，它的定义就是将<code>状态戳</code><strong>简化</strong>为<code>true|false</code>，类似一次性筷子</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicMarkableReferenceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicMarkableReference</span> <span class="variable">markableReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>(<span class="number">100</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> markableReference.isMarked();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;默认标识&quot;</span>+marked);</span><br><span class="line">            <span class="comment">//暂停1秒钟线程，等待后面的T2线程和我拿到一样的模式flag标识，都是false</span></span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            markableReference.compareAndSet(<span class="number">100</span>, <span class="number">1000</span>, marked, !marked);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> markableReference.isMarked();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;默认标识&quot;</span>+marked);</span><br><span class="line">            <span class="comment">//这里停2秒，让t1先修改,然后t2试着修改</span></span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">t2Result</span> <span class="operator">=</span> markableReference.compareAndSet(<span class="number">100</span>, <span class="number">1000</span>, marked, !marked);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;t2线程result--&quot;</span>+t2Result);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+markableReference.isMarked());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+markableReference.getReference());</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的属性修改原子类"><a href="#对象的属性修改原子类" class="headerlink" title="对象的属性修改原子类"></a>对象的属性修改原子类</h2><p>关键词FieldUpdater</p>
<ul>
<li>AtomicIntegerFieldUpdater&#x2F;&#x2F;原子更新对象中int类型字段的值</li>
<li>AtomicLongFieldUpdater&#x2F;&#x2F;原子更新对象中Long类型字段的值</li>
<li>AtomicReferenceFieldUpdater&#x2F;&#x2F;原子更新引用类型字段的值</li>
</ul>
<p>更加细粒度范围内的原子更新</p>
<img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/d1b38b7879d14f848d918ff09c4af6fc.png" alt="在这里插入图片描述" style="zoom: 67%;" />

<h3 id="使用目的"><a href="#使用目的" class="headerlink" title="使用目的"></a>使用目的</h3><ul>
<li>以一种线程安全方式操作非线程安全对象内的某些字段</li>
</ul>
<p>举个例子（它是更加细粒度的&#x2F;影像某个字段，而不用锁住整个对象）</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217201632479.png" alt="image-20230217201632479"></p>
<h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><ul>
<li>更新的对象属性必须使用<strong>public volatile</strong>修饰符</li>
<li>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法<code>newUpdater()</code>创建一个更新器，并且需要设置想要更新的类和属性。</li>
</ul>
<h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case"></a>Case</h3><ul>
<li><code>AtomicIntegerFieldUpdater</code>-这个针对int类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">BankAccount</span> <span class="variable">bankAccount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">10000</span>;i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">1000</span>;j ++)&#123;</span><br><span class="line">                        <span class="comment">// bankAccount.add();</span></span><br><span class="line">                        bankAccount.transMoney(bankAccount);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime-startTime)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;result: &quot;</span>+bankAccount.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">bankName</span> <span class="operator">=</span> <span class="string">&quot;CCB&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//条件一</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//synchronized版本</span></span><br><span class="line"><span class="comment">//    public synchronized void add()&#123;</span></span><br><span class="line"><span class="comment">//        money++;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//AtomicIntegerFieldUpdater版本</span></span><br><span class="line">    AtomicIntegerFieldUpdater&lt;BankAccount&gt; fieldUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,<span class="string">&quot;money&quot;</span>);<span class="comment">//只限制了money这个字段，条件二</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transMoney</span><span class="params">(BankAccount bankAccount)</span>&#123;</span><br><span class="line">        fieldUpdater.getAndIncrement(bankAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AtomicReferenceFieldUpdater</code>-适用度更广</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如这个案例中是针对boolean类型的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyVar</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">isInit</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">    AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; referenceFieldUpdater =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,<span class="string">&quot;isInit&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(MyVar myVar)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(referenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE))&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----start init,needs 3 seconds&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">3</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----over init&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;抱歉，已经有其他线程进行了初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceFieldUpdaterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyVar</span> <span class="variable">myVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyVar</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">5</span>;i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                myVar.init(myVar);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1  -----start init,needs 3 seconds</span></span><br><span class="line"><span class="comment">//5  抱歉，已经有其他线程进行了初始化</span></span><br><span class="line"><span class="comment">//4  抱歉，已经有其他线程进行了初始化</span></span><br><span class="line"><span class="comment">//2  抱歉，已经有其他线程进行了初始化</span></span><br><span class="line"><span class="comment">//3  抱歉，已经有其他线程进行了初始化</span></span><br><span class="line"><span class="comment">//1  -----over init</span></span><br></pre></td></tr></table></figure>

<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>面试官问你：你在哪里用了volatile?</p>
<p>在AtomicReferenceFieldUpdater中，因为是规定好的必须由volatile修饰的</p>
<p>还有的话之前我们在DCL单例中，也用了volatile保证了可见性</p>
<h2 id="原子操作增强类原理深度解析"><a href="#原子操作增强类原理深度解析" class="headerlink" title="原子操作增强类原理深度解析"></a>原子操作增强类原理深度解析</h2><p>开篇的时候我们将原子类分为了红框和蓝框，这里就是蓝框的内容</p>
<p>这几个都是java8开始有的，前面的都是java5就有了</p>
<ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<h3 id="阿里要命题目"><a href="#阿里要命题目" class="headerlink" title="阿里要命题目"></a>阿里要命题目</h3><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/4e95b66e40ce42bd963095c87767d350.png" alt="在这里插入图片描述"></p>
<ol>
<li>热点商品点赞计算器，点赞数加加统计，不要求实时精确</li>
<li>一个很大的List，里面都是int类型，如何实现加加，说说思路</li>
</ol>
<h3 id="模拟下点赞计数器，看看性能"><a href="#模拟下点赞计数器，看看性能" class="headerlink" title="模拟下点赞计数器，看看性能"></a>模拟下点赞计数器，看看性能</h3><ul>
<li><p>要求：热点商品点赞计算器，点赞数加加统计，不要求实时精确</p>
</li>
<li><p>看看这个LongAccumulator</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217212637552.png" alt="image-20230217212637552"></p>
</li>
</ul>
<h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230217212615739.png" alt="image-20230217212615739"></p>
<h4 id="入门讲解"><a href="#入门讲解" class="headerlink" title="入门讲解"></a>入门讲解</h4><p>LongAdder只能用来计算加法 <em>。且从零开始计算</em></p>
<p>LongAccumulator提供了自定义的函数操作 (利用lambda表达式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderAPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line"></span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line"></span><br><span class="line">        System.out.println(longAdder.longValue());<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x + y, <span class="number">0</span>);<span class="comment">//lambda表达式</span></span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line">        longAccumulator.accumulate(<span class="number">3</span>);<span class="comment">//4</span></span><br><span class="line">        System.out.println(longAccumulator.get());<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LongAdder高性能对比Code演示"><a href="#LongAdder高性能对比Code演示" class="headerlink" title="LongAdder高性能对比Code演示"></a>LongAdder高性能对比Code演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: yumo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 需求：50个线程，每个线程1000w次，计算总点赞数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2023/2/17 21:00</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccumulatorCompareDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1W</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_NUM</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ClickNumber</span> <span class="variable">clickNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClickNumber</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">clickBySynchronizedTime</span> <span class="operator">=</span>    execute(clickNumber, ClickNumber::clickBySynchronized);</span><br><span class="line">        <span class="type">long</span> <span class="variable">clickByAtomicLongTime</span> <span class="operator">=</span>      execute(clickNumber, ClickNumber::clickByAtomicLong);</span><br><span class="line">        <span class="type">long</span> <span class="variable">clickByLongAdderTime</span> <span class="operator">=</span>       execute(clickNumber, ClickNumber::clickByLongAdder);</span><br><span class="line">        <span class="type">long</span> <span class="variable">clickByLongAccumulatorTime</span> <span class="operator">=</span> execute(clickNumber, ClickNumber::clickByLongAccumulator);</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+clickBySynchronizedTime+<span class="string">&quot; ms\t clickBySynchronized: &quot;</span>+clickNumber.number);</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+clickByAtomicLongTime+<span class="string">&quot; ms\t clickByAtomicLong: &quot;</span>+clickNumber.atomicLong.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+clickByLongAdderTime+<span class="string">&quot; ms\t clickByLongAdder: &quot;</span>+clickNumber.longAdder.sum());</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+clickByLongAccumulatorTime+<span class="string">&quot; ms\t clickByLongAccumulator: &quot;</span>+clickNumber.longAccumulator.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">execute</span><span class="params">(ClickNumber clickNumber, Consumer&lt;ClickNumber&gt; consumer)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(THREAD_NUM);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_NUM; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span> * _1W; j++) &#123;</span><br><span class="line">                        consumer.accept(clickNumber);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime-startTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClickNumber</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clickBySynchronized</span><span class="params">()</span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByAtomicLong</span><span class="params">()</span>&#123;</span><br><span class="line">        atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAdder</span><span class="params">()</span>&#123;</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(Long::sum,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAccumulator</span><span class="params">()</span>&#123;</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//----costTime: 13853 ms	 clickBySynchronized: 500000000</span></span><br><span class="line"><span class="comment">//----costTime: 7631 ms	 clickByAtomicLong: 500000000</span></span><br><span class="line"><span class="comment">//----costTime: 585 ms	 clickByLongAdder: 500000000</span></span><br><span class="line"><span class="comment">//----costTime: 498 ms	 clickByLongAccumulator: 500000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//印证了阿里卡法手册中说的 【如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）】</span></span><br></pre></td></tr></table></figure>

<h3 id="源码、原理分析"><a href="#源码、原理分析" class="headerlink" title="源码、原理分析"></a>源码、原理分析</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218113219560.png" alt="image-20230218113219560"></p>
<p>LongAdder是Striped64的子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdder</span> <span class="keyword">extends</span> <span class="title class_">Striped64</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7249069246863182397L</span>;</span><br><span class="line"> <span class="comment">//---------------------------</span></span><br><span class="line"> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Striped64</span> <span class="keyword">extends</span> <span class="title class_">Number</span> &#123;</span><br></pre></td></tr></table></figure>



<h4 id="原理（LongAdder为什么这么快）"><a href="#原理（LongAdder为什么这么快）" class="headerlink" title="原理（LongAdder为什么这么快）"></a>原理（LongAdder为什么这么快）</h4><ul>
<li><p>官网说明</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218113350198.png"></p>
</li>
</ul>
<h5 id="Striped64"><a href="#Striped64" class="headerlink" title="Striped64"></a>Striped64</h5><ul>
<li><p>重要的成员函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Number of CPUS, to place bound on table size       </span></span><br><span class="line"><span class="comment">// CPU数量，即cells数组的最大长度 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Table of cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">//单元格数组|cells数组，为2的幂，2,4,8,16.....，方便以后位运算</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础value值，当并发较低时，只累加该值主要用于没有竞争的情况，通过CAS更新。</span></span><br><span class="line"><span class="comment">//Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment">//a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建或者扩容Cells数组时使用的自旋锁变量调整单元格大小（扩容），创建单元格时使用的锁。</span></span><br><span class="line"><span class="comment">//Spinlock (locked via CAS) used when resizing and/or creating Cells. </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最重要的两个</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218113634993.png" alt="image-20230218113634993"></p>
</li>
</ul>
</li>
<li><p>Striperd64中一些变量或者方法的定义</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218113744851.png" alt="image-20230218113744851"></p>
</li>
</ul>
<h5 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h5><p>是java.util.concurrent.atomic下Striped64的一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>LongAdder为什么这么快.</p>
<ul>
<li><p>其实在小并发下情况差不多；但在高并发情况下，在<code>AtomicLong</code>中，等待的线程会不停的自旋，导致效率比较低；而<code>LongAdder</code>用<code>cell[]</code>分了几个块出来，最后统计总的结果值（base+所有的cell值），<strong>分散热点</strong>。</p>
</li>
<li><p>举个形象的例子，火车站买火车票，<code>AtomicLong</code> 只要一个窗口，其他人都在排队；而<code>LongAdder</code> 利用<code>cell</code>开了多个卖票窗口，所以效率高了很多。</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218114633330.png" alt="image-20230218114633330"></p>
</li>
</ul>
</li>
<li><p>一句话</p>
<ul>
<li><p>LongAdder的基本思路就是<strong>分散热点</strong> ，将value值分散到一个<strong>Cell数组</strong>中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p>
</li>
<li><p>sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，<strong>从而降级更新热点</strong> 。</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218114825119.png" alt="image-20230218114825119"></p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218114837978.png" alt="image-20230218114837978"></p>
</li>
<li><p>数学表达</p>
<ul>
<li>内部有一个base变量，一个Cell[]数组。</li>
<li>base变量：非竞态条件下，直接累加到该变量上</li>
<li>Cell[]数组：竞态条件下，累加各个线程自己的槽Cell[i]中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="源码解读深度分析"><a href="#源码解读深度分析" class="headerlink" title="源码解读深度分析"></a>源码解读深度分析</h4><p><code>LongAdder</code>在无竞争的情况，跟<code>AtomicLong</code>一样，对<strong>同一个base</strong>进行操作，当出现竞争关系时则是采用<strong>化整为零分散热点</strong>的做法，从空间换时间，用一个数组 cells，将一个value拆分进这个数组cells。</p>
<p>多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。<br><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/6c09ac463901435ca58d43fd2b0c08a8.png" alt="在这里插入图片描述"></p>
<h5 id="LongAdder-increment"><a href="#LongAdder-increment" class="headerlink" title="LongAdder.increment()"></a>LongAdder.increment()</h5><h6 id="add-1L"><a href="#add-1L" class="headerlink" title="add(1L)"></a>add(1L)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdder</span> <span class="keyword">extends</span> <span class="title class_">Striped64</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7249069246863182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x the value to add</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">        Cell[] cs; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell c;</span><br><span class="line">        <span class="keyword">if</span> ((cs = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getProbe();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (cs == <span class="literal">null</span> || (m = cs.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (c = cs[index &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">                !(uncontended = c.cas(v = c.value, v + x)))</span><br><span class="line">                longAccumulate(x, <span class="literal">null</span>, uncontended, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//真正干活的是longAccumulate</span></span><br><span class="line">    <span class="comment">//cs表示cells引用</span></span><br><span class="line">    <span class="comment">//b表示获取的base值</span></span><br><span class="line">    <span class="comment">//v表示期望值</span></span><br><span class="line">    <span class="comment">//m表示cells数组的长度</span></span><br><span class="line">    <span class="comment">//c表示当前线程命中的cell单元格</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">30</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>uncontended代表没有冲突。</p>
<p>我们点进这个casBase发现他也是个CAS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casBase</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>一开始竞争小的时候CAS能成功，也就是casBase能成功，然后cells也是空的，所以不会进到循环</p>
</li>
<li><p>竞争大的时候，他会<code>Cell[] rs = new Cell[2];</code> 新建两个cell, 此时≠ null ，条件满足了，进入循环。</p>
</li>
</ul>
<p>然后这里还有一层循环，这里是多个if并排</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218124943225.png" alt="image-20230218124943225"></p>
<ul>
<li>总结一下<ol>
<li>最初无竞争时只更新base;</li>
<li>如果更新base失败后，首次新建一个Cell[]数组</li>
<li>当多个线程竞争同一个Cell比价激烈时，可能就要利用<code>longAccumulate</code>对Cell[]扩容。</li>
</ol>
</li>
</ul>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218125225202.png" alt="image-20230218125225202"></p>
<ol>
<li>如果Cells表为空，尝试用CAS更新base字段，成功则退出：</li>
<li>如果Cells表为空，CAS更新base字段失败，出现竞争，uncontended为true,调用longAccumulate;</li>
<li>如果Cells表非空，但当前线程映射的槽为空，uncontended为true,调用longAccumulate;</li>
<li>如果Cells表非空，且前线程映射的槽非空，CAS更新Ce的值，成功则返回，否则，uncontended设为false,调用longAccumulate。</li>
</ol>
<h6 id="longAccumulate"><a href="#longAccumulate" class="headerlink" title="longAccumulate()"></a>longAccumulate()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                          <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//这里是③ Cell数组不再为空且可能存在Cell数组扩容</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="literal">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)<span class="comment">//不能超过cpu核数</span></span><br><span class="line">                collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];<span class="comment">//扩容-左移一位，相当于x2</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">//这里是①初始化</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//------可以先看这里，进行了初始化，长度是2</span></span><br><span class="line">                    <span class="comment">//------cells数组，为2的幂，2，4，8，16，方便以后位运算</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))<span class="comment">//这里是②兜底</span></span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>LongAccumulate入参说明</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218132219191.png"></p>
</li>
<li><p>Striped64中一些变量或者方法的定义</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218132243773.png" alt="image-20230218132243773"></p>
</li>
<li><p>步骤</p>
<ul>
<li><p><code>(a = as[getProbe() &amp; m])</code>里的probe，这里得到了了hash值，通过hash值知道我们去到哪个cell槽</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getProbe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.getInt(Thread.currentThread(), PROBE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实就是得到了线程的Hash值</span></span><br></pre></td></tr></table></figure>

<p>所以最前面的这一段就像是新员工入职获取工号（hash值）一样</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218132532652.png" alt="image-20230218132532652"></p>
</li>
</ul>
</li>
<li><p>总纲</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218132841655.png" alt="image-20230218132841655"></p>
<p>上述代码首先给当前线程分配一个hash值，然后进入一个for(;;)自旋，这个自旋分为三个分支：</p>
<ul>
<li>CASE1：cells[]数组已经初始化</li>
<li>CASE2：cells[]数组未初始化(首次新建)</li>
<li>CASE3：cells[]数组正在初始化中</li>
</ul>
</li>
<li><p>计算</p>
<ul>
<li><p>CASE2：刚刚要初始化cells[]数组（首次新建）</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218133646309.png" alt="image-20230218133646309"></p>
</li>
</ul>
<p>如果上面条件都执行成功就会执行数组的初始化及赋值操作， Cell[] rs &#x3D; new Cell[2]表示数组的长度为2，<br>rs[h &amp; 1] &#x3D; new Cell(x) 表示创建一个新的Cell元素，value是x值，默认为1。<br>h &amp; 1类似于我们之前HashMap常用到的计算散列桶index的算法，通常都是hash &amp; (table.len - 1)。同hashmap一个意思。</p>
</li>
<li><p>CASE3：cells[]数组正在初始化中。兜底</p>
<p>多个线程尝试CAS修改失败的线程会走到这个分支</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fall back on using base</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base,</span><br><span class="line">				(fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x)))</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//该分支实现直接操作base基数，将值累加到base上，也即其它线程正在初始化，多个线程正在更新base的值。</span></span><br></pre></td></tr></table></figure>

<p>若一个线程cas操作为false，则继续自旋</p>
</li>
<li><p>CASE1：cells[]数组已经初始化且可能存在数组扩容</p>
<ul>
<li><p>多个线程同时命中一个cell的竞争,这个是<strong>最复杂</strong>的部分</p>
<ol>
<li><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218135606027.png" alt="image-20230218135606027"></p>
<ul>
<li>上面代码判断当前线程hash后指向的数据位置元素是否为空，</li>
<li>如果为空则将Cell数据放入数组中，跳出循环。</li>
<li>如果不空则继续循环。</li>
</ul>
</li>
<li><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218135849240.png" alt="image-20230218135849240"></p>
</li>
<li><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140007490.png"></p>
<p>说明当前线程对应的数组中有了数据，也重置过hash值，<br>这时通过CAS操作尝试对当前数中的value值进行累加x操作，x默认为1，如果CAS成功则直接跳出循环。</p>
</li>
<li><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140123894.png" alt="image-20230218140123894"></p>
</li>
<li><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140245454.png" alt="image-20230218140245454"></p>
</li>
<li><p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140354879.png" alt="image-20230218140354879"></p>
</li>
</ol>
</li>
<li><p>以上六步总结</p>
<p><img src="https://yumoimgbed.oss-cn-shenzhen.aliyuncs.com/img/image-20230218140759151.png" alt="image-20230218140759151"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h6 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LongAdder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sum()会将所有Cell数组中的<strong>value和base累加</strong>作为返回值。<br>核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而<strong>降级更新热点</strong> 。</p>
<blockquote>
<p>为啥在并发情况下sum的值不精确？</p>
</blockquote>
<p>sum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是<strong>最终一致性</strong>的。</p>
<ul>
<li>首先，最终返回的sum局部变量，初始被复制为base，而最终返回时，很可能base已经被更新了 ，而此时局部变量sum不会更新，造成不一致。</li>
<li>其次，这里对cell的读取也无法保证是最后一次写入的值。所以，sum方法在没有并发的情况下，可以获得正确的结果。</li>
</ul>
<h4 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h4><ul>
<li>AtomicLong<ul>
<li>线程安全，可允许一些性能损耗，要求<strong>高精度</strong>时可使用</li>
<li>保证精度，性能代价</li>
<li>AtomicLong是多个线程针对单个热点值value进行原子操作</li>
</ul>
</li>
<li>LongAdder<ul>
<li>当需要在高并发下有较好的性能表现，且<strong>对值的精确度要求不高</strong>时，可以使用</li>
<li>保证性能，精度代价</li>
<li>LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作</li>
</ul>
</li>
</ul>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><h4 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul>
<li>CAS+自旋</li>
<li>incrementAndGet</li>
</ul>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><ul>
<li>低并发下的全局计算</li>
<li>AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题</li>
</ul>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul>
<li>高并发后性能急剧下降</li>
<li>why?AtomicLong的自旋会称为瓶颈（N个线程CAS操作修改线程的值，每次只有一个成功过，其它N - 1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。）</li>
</ul>
<h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><ul>
<li>CAS+Base+Cell数组分散</li>
<li>空间换时间并分散了热点数据</li>
</ul>
<h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><ul>
<li>高并发的全局计算</li>
</ul>
<h5 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h5><ul>
<li>sum求和后还有计算线程修改结果的话，最后结果不够准确</li>
</ul>
<hr>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
  </div>
  <script src="https://giscus.app/client.js"
        data-repo="yumoyum0/yumoyum0.github.io"
        data-repo-id="R_kgDOKZzJIg"
        data-category="Announcements"
        data-category-id="DIC_kwDOKZzJIs4CZwB8"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Archives</a></li>
        
          <li><a href="/tags/">Tags</a></li>
        
          <li><a href="/categories/">Categorys</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/search/">Search</a></li>
        
          <li><a href="/atom.xml">RSS</a></li>
        
          <li><a href="/infinite/">Infinite</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS"><span class="toc-number">1.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89CAS%E4%B9%8B%E5%89%8D"><span class="toc-number">1.2.</span> <span class="toc-text">没有CAS之前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8CAS%E4%B9%8B%E5%90%8E"><span class="toc-number">1.3.</span> <span class="toc-text">使用CAS之后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.</span> <span class="toc-text">CAS是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">CAS基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">CAS原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CASDemo%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.3.</span> <span class="toc-text">CASDemo代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BA%A7%E5%88%AB%E4%BF%9D%E8%AF%81"><span class="toc-number">1.4.4.</span> <span class="toc-text">硬件级别保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.5.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9F%E5%A6%82%E6%9E%9C%E7%9F%A5%E9%81%93%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9UnSafe%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">CAS底层原理？如果知道，谈谈你对UnSafe的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UnSafe"><span class="toc-number">1.5.1.</span> <span class="toc-text">UnSafe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93i-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E9%82%A3atomicInteger-getAndIncrement"><span class="toc-number">1.5.2.</span> <span class="toc-text">我们知道i++线程不安全的，那atomicInteger.getAndIncrement()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%B1%87%E7%BC%96"><span class="toc-number">1.5.4.</span> <span class="toc-text">底层汇编</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">自定义原子引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E4%B8%8E%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E5%80%9F%E9%89%B4CAS%E6%80%9D%E6%83%B3"><span class="toc-number">1.7.</span> <span class="toc-text">CAS与自旋锁，借鉴CAS思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81SpinLockDemo"><span class="toc-number">1.7.2.</span> <span class="toc-text">自己实现一个自旋锁SpinLockDemo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E7%BC%BA%E7%82%B9"><span class="toc-number">1.8.</span> <span class="toc-text">CAS缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%BE%88%E5%A4%A7"><span class="toc-number">1.8.1.</span> <span class="toc-text">1 循环时间长开销很大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E5%87%BA%E6%9D%A5ABA%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.2.</span> <span class="toc-text">2 引出来ABA问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">原子操作类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">再分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">基本类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-number">2.3.1.</span> <span class="toc-text">常用API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-CountDownLatch"><span class="toc-number">2.3.2.</span> <span class="toc-text">Case-CountDownLatch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">数组类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Case"><span class="toc-number">2.4.1.</span> <span class="toc-text">Case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">引用类型原子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text">对象的属性修改原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84"><span class="toc-number">2.6.1.</span> <span class="toc-text">使用目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A6%81%E6%B1%82"><span class="toc-number">2.6.2.</span> <span class="toc-text">使用要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-1"><span class="toc-number">2.6.3.</span> <span class="toc-text">Case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">2.6.4.</span> <span class="toc-text">面试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%BC%BA%E7%B1%BB%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">2.7.</span> <span class="toc-text">原子操作增强类原理深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E8%A6%81%E5%91%BD%E9%A2%98%E7%9B%AE"><span class="toc-number">2.7.1.</span> <span class="toc-text">阿里要命题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%B8%8B%E7%82%B9%E8%B5%9E%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%8C%E7%9C%8B%E7%9C%8B%E6%80%A7%E8%83%BD"><span class="toc-number">2.7.2.</span> <span class="toc-text">模拟下点赞计数器，看看性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API-1"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">常用API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">入门讲解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LongAdder%E9%AB%98%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94Code%E6%BC%94%E7%A4%BA"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">LongAdder高性能对比Code演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">2.7.3.</span> <span class="toc-text">源码、原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%88LongAdder%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%89"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">原理（LongAdder为什么这么快）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Striped64"><span class="toc-number">2.7.3.2.1.</span> <span class="toc-text">Striped64</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Cell"><span class="toc-number">2.7.3.2.2.</span> <span class="toc-text">Cell</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">源码解读深度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LongAdder-increment"><span class="toc-number">2.7.3.3.1.</span> <span class="toc-text">LongAdder.increment()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#add-1L"><span class="toc-number">2.7.3.3.1.1.</span> <span class="toc-text">add(1L)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#longAccumulate"><span class="toc-number">2.7.3.3.1.2.</span> <span class="toc-text">longAccumulate()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sum"><span class="toc-number">2.7.3.3.1.3.</span> <span class="toc-text">sum()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.3.4.</span> <span class="toc-text">使用总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.4.</span> <span class="toc-text">小总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicLong"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">AtomicLong</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.4.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.4.1.2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">2.7.4.1.3.</span> <span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LongAdder"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">LongAdder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.7.4.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.7.4.2.2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7-1"><span class="toc-number">2.7.4.2.3.</span> <span class="toc-text">缺陷</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text"></span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&text=CAS与原子操作类"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&is_video=false&description=CAS与原子操作类"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CAS与原子操作类&body=Check out this article: https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&title=CAS与原子操作类"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&name=CAS与原子操作类&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://username.github.io/2023/02/18/Java/%E5%B9%B6%E5%8F%91/CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/&t=CAS与原子操作类"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2023
    Yumo
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Archives</a></li><!--
     --><!--
       --><li><a href="/tags/">Tags</a></li><!--
     --><!--
       --><li><a href="/categories/">Categorys</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     --><!--
       --><li><a href="/atom.xml">RSS</a></li><!--
     --><!--
       --><li><a href="/infinite/">Infinite</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"left","hOffset":20,"vOffset":0},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
